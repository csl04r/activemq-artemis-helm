# -- number of replicas in the stateful set. Do not set value greater than 1 unless you have a good reason
replicaCount: 1
# -- secret values for AppRole authentication to HashiCorp vault. These are used to sign a CSR and get a valid cert for the broker.
appRoleSecrets:
  # -- the role ID for the AppRole
  roleId: ""
  # -- the secret ID for the AppRole
  secretId: ""

image:
  # -- required value to identify the image
  repository: docker.artifactory.sherwin.com/sherwin-williams-co/activemq-shw-extensions

  # -- required value to identify the image
  tag: ""
  pullPolicy: IfNotPresent
  pullSecrets: [ ]

# -- JVM arguments to include on the artemis server command line
javaArgs: >-
  -XX:AutoBoxCacheMax=20000 
  -XX:+PrintClassHistogram 
  -XX:+UseG1GC 
  -XX:+UseStringDeduplication 
  -Xms512M 
  -Xmx512M 
  -Dhawtio.contextPath=/console 
  -Dhawtio.proxy.basePath=/console/jolokia 
  -Dhawtio.disableProxy=true 
  -Dhawtio.realm=activemq 
  -Dhawtio.offline=true 
  -Dhawtio.rolePrincipalClasses=org.apache.activemq.artemis.spi.core.security.jaas.RolePrincipal 
  -Dhawtio.http.strictTransportSecurity=max-age=31536000;includeSubDomains;preload 
  -Djolokia.policyLocation=file:///var/lib/artemis-instance/etc/jolokia-access.xml 
  -Dlog4j2.disableJmx=true 
  --add-opens java.base/jdk.internal.misc=ALL-UNNAMED

# Rule of thumb for memory calculation: 1.3 * max_heap + 128Mi
resources:
  limits:
    memory: 794Mi # round(1.3 * 512Mi) + 128Mi
  requests:
    cpu: 100m
    memory: 794Mi

persistence:
  # -- if true, then use persistent storage (recommended for production)
  enabled: true
  # -- used to build the PVC for the stateful set
  accessModes:
    - ReadWriteOnce
  # -- used to build the PVC for the stateful set
  storageSize: 8Gi
  # -- used to build the PVC for teh stateful set
  storageClassName: "longhorn"

  # livenessProbe:
  # httpGet:
  #   port: http
  # initialDelaySeconds: 120
  # periodSeconds: 10

readinessProbe:
  tcpSocket:
    port: netty
  initialDelaySeconds: 5
  periodSeconds: 10

metrics:
  # -- if `true` export prometheus metrics
  enabled: true
  serviceMonitor:
    # -- if `true` and metrics.enabled `true` then deploy service monitor
    enabled: false
    # -- namespace where serviceMonitor is deployed
    namespace: monitoring
    # -- Prometheus scraping path
    path: /metrics
    # -- Prometheus scraping interval
    interval: 10s

# -- additional core settings. Key, values are automatically expanded
core:
  # -- how to behave on critical errors detected, see https://activemq.apache.org/components/artemis/documentation/latest/critical-analysis.html
  criticalAnalyzerPolicy: SHUTDOWN

# -- list of named address (JMS destinations) to pre-populate in the broker
addresses:
  - name: DLQ
  - name: ExpiryQueue

# -- list of address settings to include in the broker.xml
addressSettings:
  # -- pattern of address name to match, use `#` for wildcard
  - match: "#"
    # -- settings to add to the address
    settings:
      # -- configures the address settings, see the artemis docs for details
      deadLetterAddress: DLQ
      # -- configures the address settings, see the artemis docs for details
      expiryAddress: ExpiryQueue
      # -- configures the address settings, see the artemis docs for details
      messageCounterHistoryDayLimit: 10
tls:
  # -- if `true`, will create a self-signed certificate and require remote connections to use TLS, i.e. by adding `?sslEnabled=true;trustAll=true` to the broker connection URL
  enabled: true
  # -- a map of name-value pairs to be converted into the form n1=v1;n2=v2 and appended to broker acceptor connection URLs
  parameters:
    # -- whether to use SSL/TLS
    sslEnabled: "true"
    # -- keystore holding key & cert for the broker
    keyStorePath: /var/lib/artemis-instance/tls/tls.p12
    # -- password for the keystore
    keyStorePassword: securepass
    # -- type of keystore
    keyStoreType: PKCS12
    # -- alias in the keystore for the key & cert
    keyStoreAlias: server
    # -- truststore holding CA certs for the broker
#    trustStorePath: /var/lib/artemis-instance/data/tls/server-ca-truststore.p12
    # -- password for the truststore
#    trustStorePassword: securepass
    # -- type of truststore
#    trustStoreType: PKCS12
debugger:
  # -- if `true` starts the JVM with arguments to allow remote debugging
  enabled: false
  # -- the port to listen for remote debugging connections
  port: 8000


# -- allows setting security context for the pod: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
podSecurityContext:
  # -- if `true` run the container as a non-root user
  runAsNonRoot: true
  # -- the user id to use when running the container
  runAsUser: 1001
  # -- the group id to use when running the container
  runAsGroup: 1001
  # -- group id of mounted volumes (must match runAsGroup for this to work)
  fsGroup: 1001

podSecurityAdmission:
  # -- if `true` add a pod security policy admission annotations to the pod
  enabled: true
  # -- must be one of `enforce`, `audit`, or `warn`
  mode: enforce
  # -- must be one of `privileged`, `baseline`, or `restricted`.
  level: restricted
  # -- must be a valid Kubernetes minor version, or `latest`
  version: latest

nodeSelector: { }

tolerations: [ ]

affinity: { }

service:
  loadBalancer:
    annotations:
      metallb.universe.tf/allow-shared-ip: "172.30.0.8"
      metallb.universe.tf/ip-allocated-from-pool: default-pool

security:
  # -- security configuration for clients running in the same Kubernetes cluster
  kubernetes:
    # -- if `true` allow kubernetes service account token authentication and authorization
    enabled: true
    clients:
      # -- moniker for a known application that will connect from the same k8s cluster, used to create an AMQ role and destination prefix
      - name: OURAPP
        # -- the fully qualified service account name to acquire this AMQ role
        fullyQualifiedServiceAccountName: system:serviceaccount:our-namespace:our-app
    # -- maps ActiveMQ roles to a list of k8s principals
    roleAliases:
      # -- name of the ActiveMQ role to assign
      some-amq-role: # the activemq role to assign
        # -- list of k8s prinicpals to get the above ActiveMQ role
        - system:serviceaccount:shw-na-pos:pol
        - system:serviceaccount:shw-na-pos:shercolor
  oauth2:
    # -- if `true` use OAuth2 JWT token authentication and authorization
    enabled: true
    # -- LoginModule implementation class
    jaasModule: shw.activemq.extension.security.OAuth2LoginModule
    # -- In Microsoft Entra, the tenant ID in use
    tenantId: 44b79a67-d972-49ba-9167-8eb05f754a1a
    # -- audience in JWT which identifies this group of ActiveMQ services
    audience: 8bddbe55-946d-4033-8832-a1e752e97709
    # -- URL of the OAuth2 issuer
    issuerUrl: https://login.microsoftonline.com/44b79a67-d972-49ba-9167-8eb05f754a1a/v2.0
    # -- name of claim in the JWT containing strings to alias to an ActiveMQ role
    rolesClaimName: roles
    # -- maps JWT roles to ActiveMQ roles. The ActiveMQ roles are the keys which take a list of JWT roles to which to grant the ActiveMQ role.
    roleAliases:
      # -- the ActiveMQ role to assign to the subject presenting the JWT
      some-amq-role:
        # -- elements that, when any are present in the JWT, will qualify the JWT presenter to get the above ActiveMQ role
        - CCN.BANKCARD.INFO
        - CCN.STORE.INFO

pycertmanager:
  # -- if `true` use [pycertmanager](https://github.com/sherwin-williams-co/pycertmanager) to manage the TLS certs and PCKS#12 keystore for the broker. If `false`, do it yourself some other way. TLS certs are required.
  enabled: true
  image:
    repository: docker.artifactory.sherwin.com/sherwin-williams-co/pycertmanager
    tag: 0.1.4