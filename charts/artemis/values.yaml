# -- number of replicas in the stateful set. Do not set value greater than 1 unless you have a good reason
replicaCount: 1
# -- secret values for AppRole authentication to HashiCorp vault. These are used to sign a CSR and get a valid cert for the broker.
appRoleSecrets:
  # -- the role ID for the AppRole
  roleId: ""
  # -- the secret ID for the AppRole
  secretId: ""

image:
  # -- required value to identify the image
  repository: docker.artifactory.sherwin.com/sherwin-williams-co/activemq-shw-extensions

  # -- required value to identify the image
  tag: ""
  pullPolicy: IfNotPresent
  pullSecrets: [ ]

# -- JVM arguments to include on the artemis server command line
javaArgs: >-
  -XX:AutoBoxCacheMax=20000 
  -XX:+PrintClassHistogram 
  -XX:+UseG1GC 
  -XX:+UseStringDeduplication  
  -XX:+UseContainerSupport
  -XX:MaxRAMPercentage=75.0
  -XX:InitialRAMPercentage=50.0  
  -Dhawtio.contextPath=/console 
  -Dhawtio.proxy.basePath=/console/jolokia 
  -Dhawtio.disableProxy=true 
  -Dhawtio.realm=activemq 
  -Dhawtio.offline=true 
  -Dhawtio.rolePrincipalClasses=org.apache.activemq.artemis.spi.core.security.jaas.RolePrincipal 
  -Dhawtio.http.strictTransportSecurity=max-age=31536000;includeSubDomains;preload 
  -Djolokia.policyLocation=file:///var/lib/artemis-instance/etc/jolokia-access.xml 
  -Dlog4j2.disableJmx=true 
  --add-opens java.base/jdk.internal.misc=ALL-UNNAMED

# Rule of thumb for memory calculation: 1.3 * max_heap + 128Mi
resources:
  limits:
    memory: 1Gi # round(1.3 * 1024Mi) + 128Mi
    cpu: 1000m
  requests:
    cpu: 100m
    memory: 1Gi

persistence:
  # -- if true, then use persistent storage (recommended for production)
  enabled: true
  # -- used to build the PVC for the stateful set
  accessModes:
    - ReadWriteOnce
  # -- used to build the PVC for the stateful set
  storageSize: 8Gi
  # -- used to build the PVC for teh stateful set
  storageClassName: "longhorn"

  # livenessProbe:
  # httpGet:
  #   port: http
  # initialDelaySeconds: 120
  # periodSeconds: 10
#startupProbe:
#  exec:
#    command:
#      - artemis_healthcheck
#  failureThreshold: 30
#  periodSeconds: 5
livenessProbe:
  exec:
    command:
      - artemis_healthcheck
  initialDelaySeconds: 30
  periodSeconds: 20
readinessProbe:
  tcpSocket:
    port: netty
  initialDelaySeconds: 5
  periodSeconds: 10

metrics:
  # -- if `true` export prometheus metrics
  enabled: true
  serviceMonitor:
    # -- if `true` and metrics.enabled `true` then deploy service monitor
    enabled: false
    # -- namespace where serviceMonitor is deployed
    namespace: monitoring
    # -- Prometheus scraping path
    path: /metrics
    # -- Prometheus scraping interval
    interval: 10s

# -- additional core settings. Key, values are automatically expanded
core:
  # -- how to behave on critical errors detected, see https://activemq.apache.org/components/artemis/documentation/latest/critical-analysis.html
  criticalAnalyzerPolicy: SHUTDOWN

# -- list of named address (JMS destinations) to pre-populate in the broker
addresses:
  - name: DLQ
  - name: ExpiryQueue

# -- list of address settings to include in the broker.xml
addressSettings:
  # -- pattern of address name to match, use `#` for wildcard
  - match: "#"
    # -- settings to add to the address
    settings:
      # -- configures the address settings, see the artemis docs for details
      deadLetterAddress: DLQ
      # -- configures the address settings, see the artemis docs for details
      expiryAddress: ExpiryQueue
      # -- configures the address settings, see the artemis docs for details
      messageCounterHistoryDayLimit: 10
tls:
  # -- if `true`, will create a self-signed certificate and require remote connections to use TLS, i.e. by adding `?sslEnabled=true;trustAll=true` to the broker connection URL
  enabled: true
  # -- a map of name-value pairs to be converted into the form n1=v1;n2=v2 and appended to broker acceptor connection URLs
  parameters:
    # -- whether to use SSL/TLS
    sslEnabled: "true"
    # -- keystore holding key & cert for the broker
    keyStorePath: /var/lib/artemis-instance/tls/tls.p12
    # -- password for the keystore
    keyStorePassword: securepass
    # -- type of keystore
    keyStoreType: PKCS12
    # -- alias in the keystore for the key & cert
    keyStoreAlias: server
    # -- truststore holding CA certs for the broker
#    trustStorePath: /var/lib/artemis-instance/data/tls/server-ca-truststore.p12
    # -- password for the truststore
#    trustStorePassword: securepass
    # -- type of truststore
#    trustStoreType: PKCS12
debugger:
  # -- if `true` starts the JVM with arguments to allow remote debugging
  enabled: false
  # -- the port to listen for remote debugging connections
  port: 8000

# -- snippets to include in the broker.xml file based on section. The snippets are rendered as XML and must conform
#    to the schema of the broker.xml file. Caution must be used to ensure that conflicts do not occur with the default values.
snippets:
  # -- extra security settings expressed as XML to include in the <security-settings> section of broker.xml
  securitySettings: ""
  # -- extra address settings expressed as XML to include in the <address-settings> section of broker.xml
  addressSettings: ""
  # -- extra addresses expressed as XML to include in the <addresses> section of broker.xml
  addresses: ""
  # -- extra core configuration expressed as XML to include in the <core> section of broker.xml
  core: ""


# -- allows setting security context for the pod: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
podSecurityContext:
  # -- if `true` run the container as a non-root user
  runAsNonRoot: true
  # -- the user id to use when running the container
  runAsUser: 1001
  # -- the group id to use when running the container
  runAsGroup: 1001
  # -- group id of mounted volumes (must match runAsGroup for this to work)
  fsGroup: 1001

podSecurityAdmission:
  # -- if `true` add a pod security policy admission annotations to the pod
  enabled: true
  # -- must be one of `enforce`, `audit`, or `warn`
  mode: enforce
  # -- must be one of `privileged`, `baseline`, or `restricted`.
  level: restricted
  # -- must be a valid Kubernetes minor version, or `latest`
  version: latest

nodeSelector: { }

tolerations: [ ]

affinity: { }

service:
  loadBalancer:
    annotations:
      metallb.universe.tf/allow-shared-ip: "172.30.0.8"
      metallb.universe.tf/ip-allocated-from-pool: default-pool

security:
  # -- security configuration for clients running in the same Kubernetes cluster
  kubernetes:
    # -- if `true` allow kubernetes service account token authentication and authorization
    enabled: true
    clients: []
#      # -- moniker for a known application that will connect from the same k8s cluster, used to create an AMQ role and destination prefix
#      - name: OURAPP
#        # -- the fully qualified service account name to acquire this AMQ role
#        fullyQualifiedServiceAccountName: system:serviceaccount:our-namespace:our-app
    # -- maps ActiveMQ roles to a list of k8s principals
    roleAliases: {}
      # -- name of the ActiveMQ role to assign
#      amq: # Super-user role in Artemis
#        - system:serviceaccount:shw-na-pos:kafka-router
#      # -- name of the ActiveMQ role to assign
#      some-amq-role: # the activemq role to assign
#        # -- list of k8s prinicpals to get the above ActiveMQ role
#        - system:serviceaccount:shw-na-pos:pol
#        - system:serviceaccount:shw-na-pos:shercolor
  oauth2:
    # -- if `true` use OAuth2 JWT token authentication and authorization
    enabled: true
    # -- LoginModule implementation class
    jaasModule: shw.activemq.extension.security.OAuth2LoginModule
    # -- In Microsoft Entra, the tenant ID in use
    tenantId: 44b79a67-d972-49ba-9167-8eb05f754a1a
    # -- audience in JWT which identifies this group of ActiveMQ services
    audience: 8bddbe55-946d-4033-8832-a1e752e97709
    # -- URL of the OAuth2 issuer
    issuerUrl: https://login.microsoftonline.com/44b79a67-d972-49ba-9167-8eb05f754a1a/v2.0
    # -- name of claim in the JWT containing strings to alias to an ActiveMQ role
    rolesClaimName: roles
    # -- maps JWT roles to ActiveMQ roles. The ActiveMQ roles are the keys which take a list of JWT roles to which to grant the ActiveMQ role.
    roleAliases: {}
#      # -- the ActiveMQ role to assign to the subject presenting the JWT
#      some-amq-role:
#        # -- elements that, when any are present in the JWT, will qualify the JWT presenter to get the above ActiveMQ role
#        - CCN.BANKCARD.INFO
#        - CCN.STORE.INFO

# -- additional broker properties to specify as a broker.properties file
brokerProperties: ""
#brokerProperties: |
#  # Additional properties to fine-tune broker config
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ".name=OMS.ORDER.UPDATE.AMQ
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ".queueConfigurations."OMS.ORDER.UPDATE.AMQ".address=OMS.ORDER.UPDATE.AMQ
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ".queueConfigurations."OMS.ORDER.UPDATE.AMQ".consumersBeforeDispatch=0
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ".queueConfigurations."OMS.ORDER.UPDATE.AMQ".delayBeforeDispatch=-1
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ".queueConfigurations."OMS.ORDER.UPDATE.AMQ".durable=true
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ".queueConfigurations."OMS.ORDER.UPDATE.AMQ".enabled=true
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ".queueConfigurations."OMS.ORDER.UPDATE.AMQ".exclusive=false
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ".queueConfigurations."OMS.ORDER.UPDATE.AMQ".groupBuckets=-1
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ".queueConfigurations."OMS.ORDER.UPDATE.AMQ".groupRebalance=false
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ".queueConfigurations."OMS.ORDER.UPDATE.AMQ".lastValue=false
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ".queueConfigurations."OMS.ORDER.UPDATE.AMQ".maxConsumers=-1
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ".queueConfigurations."OMS.ORDER.UPDATE.AMQ".name=OMS.ORDER.UPDATE.AMQ
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ".queueConfigurations."OMS.ORDER.UPDATE.AMQ".nonDestructive=false
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ".queueConfigurations."OMS.ORDER.UPDATE.AMQ".ringSize=-1
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ".queueConfigurations."OMS.ORDER.UPDATE.AMQ".routingType=ANYCAST
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ".routingTypes=ANYCAST
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".name=OMS.ORDER.UPDATE.AMQ.TEST
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".queueConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".address=OMS.ORDER.UPDATE.AMQ.TEST
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".queueConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".consumersBeforeDispatch=0
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".queueConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".delayBeforeDispatch=-1
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".queueConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".durable=true
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".queueConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".enabled=true
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".queueConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".exclusive=false
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".queueConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".groupBuckets=-1
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".queueConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".groupRebalance=false
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".queueConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".lastValue=false
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".queueConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".maxConsumers=-1
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".queueConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".name=OMS.ORDER.UPDATE.AMQ.TEST
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".queueConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".nonDestructive=false
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".queueConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".ringSize=-1
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".queueConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".routingType=ANYCAST
#  addressConfigurations."OMS.ORDER.UPDATE.AMQ.TEST".routingTypes=ANYCAST
#  divertConfigurations.debug-order-update.address=OMS.ORDER.UPDATE.AMQ
#  divertConfigurations.debug-order-update.forwardingAddress=OMS.ORDER.UPDATE.AMQ.TEST

log42Properties: |
  # Log4J 2 configuration
  # Monitor config file every X seconds for updates
  monitorInterval = 5

  rootLogger.level = WARN
  rootLogger.appenderRef.console.ref = console
  rootLogger.appenderRef.log_file.ref = log_file

  logger.activemq.name=org.apache.activemq
  logger.activemq.level=INFO

  logger.security.name=org.apache.activemq.artemis.spi.core.security.jaas
  logger.security.level=WARN

  logger.artemis_server.name=org.apache.activemq.artemis.core.server
  logger.artemis_server.level=INFO

  logger.artemis_journal.name=org.apache.activemq.artemis.journal
  logger.artemis_journal.level=INFO

  logger.artemis_utils.name=org.apache.activemq.artemis.utils
  logger.artemis_utils.level=INFO

  # CriticalAnalyzer: If you have issues with the CriticalAnalyzer, setting this to TRACE would give
  # you extra troubleshooting info, but do not use TRACE regularly as it would incur extra CPU usage.
  logger.critical_analyzer.name=org.apache.activemq.artemis.utils.critical
  logger.critical_analyzer.level=INFO

  # Audit loggers: to enable change levels from OFF to INFO
  logger.audit_base.name = org.apache.activemq.audit.base
  logger.audit_base.level = OFF
  logger.audit_base.appenderRef.audit_log_file.ref = audit_log_file
  logger.audit_base.additivity = false

  logger.audit_resource.name = org.apache.activemq.audit.resource
  logger.audit_resource.level = OFF
  logger.audit_resource.appenderRef.audit_log_file.ref = audit_log_file
  logger.audit_resource.additivity = false

  logger.audit_message.name = org.apache.activemq.audit.message
  logger.audit_message.level = OFF
  logger.audit_message.appenderRef.audit_log_file.ref = audit_log_file
  logger.audit_message.additivity = false

  # Jetty logger levels
  logger.jetty.name=org.eclipse.jetty
  logger.jetty.level=WARN

  # web console authenticator too verbose for impatient client
  logger.authentication_filter.name=io.hawt.web.auth.AuthenticationFilter
  logger.authentication_filter.level=ERROR

  # Quorum related logger levels
  logger.curator.name=org.apache.curator
  logger.curator.level=WARN
  logger.zookeeper.name=org.apache.zookeeper
  logger.zookeeper.level=ERROR

  # Console appender
  appender.console.type=Console
  appender.console.name=console
  appender.console.layout.type=PatternLayout
  appender.console.layout.pattern=%-5level [%logger] %msg%n

  # Log file appender
  appender.log_file.type = RollingFile
  appender.log_file.name = log_file
  appender.log_file.fileName = ${sys:artemis.instance}/log/artemis.log
  appender.log_file.filePattern = ${sys:artemis.instance}/log/artemis.log.%d{yyyy-MM-dd}
  appender.log_file.layout.type = PatternLayout
  appender.log_file.layout.pattern = %d %-5level [%logger] %msg%n
  appender.log_file.policies.type = Policies
  appender.log_file.policies.cron.type = CronTriggeringPolicy
  appender.log_file.policies.cron.schedule = 0 0 0 * * ?
  appender.log_file.policies.cron.evaluateOnStartup = true

  # Audit log file appender
  appender.audit_log_file.type = RollingFile
  appender.audit_log_file.name = audit_log_file
  appender.audit_log_file.fileName = ${sys:artemis.instance}/log/audit.log
  appender.audit_log_file.filePattern = ${sys:artemis.instance}/log/audit.log.%d{yyyy-MM-dd}
  appender.audit_log_file.layout.type = PatternLayout
  appender.audit_log_file.layout.pattern = %d [AUDIT](%t) %msg%n
  appender.audit_log_file.policies.type = Policies
  appender.audit_log_file.policies.cron.type = CronTriggeringPolicy
  appender.audit_log_file.policies.cron.schedule = 0 0 0 * * ?
  appender.audit_log_file.policies.cron.evaluateOnStartup = true
pycertmanager:
  # -- if `true` use [pycertmanager](https://github.com/sherwin-williams-co/pycertmanager) to manage the TLS certs and PCKS#12 keystore for the broker. If `false`, do it yourself some other way. TLS certs are required.
  enabled: true
  image:
    repository: docker.artifactory.sherwin.com/sherwin-williams-co/pycertmanager
    tag: 0.1.6
